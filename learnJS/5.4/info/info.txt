let arr = new Array();
let arr = [];

(!)…Или добавить новый к существующему массиву:
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]

(!)Вывести массив целиком можно при помощи alert.
let fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits ); // Яблоко, Апельсин, Слива

(!)В массиве могут храниться элементы любого типа.
Например:
// разные типы значений
let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];
// получить элемент с индексом 1 (объект) и затем показать его свойство
alert( arr[1].name ); // Джон
// получить элемент с индексом 3 (функция) и выполнить её
arr[3](); // привет

(!)Список элементов массива, как и список свойств объекта, может оканчиваться запятой

(!)Другими словами, arr.at(i):
1)это ровно то же самое, что и arr[i], если i >= 0.
2)для отрицательных значений i, он отступает от конца массива.
////////////////////////////////////////////////////////////////
(!)Методы, работающие с концом массива:
(!)pop - Удаляет последний элемент из массива и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.pop() ); // удаляем "Груша" и выводим его

alert( fruits ); // Яблоко, Апельсин
(!)push - Добавляет элемент в конец массива:

let fruits = ["Яблоко", "Апельсин"];

fruits.push("Груша");

alert( fruits ); // Яблоко, Апельсин, Груша

(!)Методы, работающие с началом массива:
(!)shift
Удаляет из массива первый элемент и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];

alert( fruits.shift() ); // удаляем Яблоко и выводим его

alert( fruits ); // Апельсин, Груша
(!)unshift
Добавляет элемент в начало массива:

let fruits = ["Апельсин", "Груша"];

fruits.unshift('Яблоко');

alert( fruits ); // Яблоко, Апельсин, Груша
(!)Методы push и unshift могут добавлять сразу несколько элементов:

let fruits = ["Яблоко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
alert( fruits );
/////////////////////////////////////////////////////////////
(!)Варианты неправильного применения массива:
1)Добавление нечислового свойства, например: arr.test = 5.
2)Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
3)Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.
//////////////////////////////////////////////////////////////
(!)Методы push/pop выполняются быстро, а методы shift/unshift – медленно.
(!)Для перебора массива лучше использовать for of
(!)Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.
(!)Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
alert( matrix[1][1] ); // 5, центральный элемент
///////////////////////////////////////////////////////////
Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

Например:

let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
Давайте теперь попробуем следующее:

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString, таким образом, здесь [] становится пустой строкой, 
[1] становится "1", а [1,2] становится "1,2".

Когда бинарный оператор плюс "+" добавляет что-либо к строке, он тоже преобразует это в строку, таким образом:

alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
////////////////////////////////////////////////////////////////
В JavaScript, в отличие от некоторых других языков программирования, массивы не следует сравнивать при помощи оператора ==.
У этого оператора нет специального подхода к массивам, он работает с ними, как и с любыми другими объектами.
Сравнивать надо по элементно
