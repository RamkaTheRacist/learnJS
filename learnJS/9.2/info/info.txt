(!)Давайте создадим class Rabbit, который наследуется от Animal:

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(5); // Белый кролик бежит со скоростью 5.
rabbit.hide(); // Белый кролик прячется!

/////////////////////////////////////////////////////////////////////////

Синтаксис создания класса допускает указывать после extends не только класс, но и любое выражение.

Пример вызова функции, которая генерирует родительский класс:

function f(phrase) {
  return class {
    sayHi() { alert(phrase); }
  };
}

class User extends f("Привет") {}

new User().sayHi(); // Привет
Здесь class User наследует от результата вызова f("Привет").

Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.

/////////////////////////////////////////////////////////////////////////

У классов есть ключевое слово "super" для таких случаев.

super.method(...) вызывает родительский метод.
super(...) для вызова родительского конструктора (работает только внутри нашего конструктора).
Пусть наш кролик автоматически прячется при остановке:

class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} бежит со скоростью ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} стоит неподвижно.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }

  stop() {
    super.stop(); // вызываем родительский метод stop
    this.hide(); // и затем hide
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(5); // Белый кролик бежит со скоростью 5.
rabbit.stop(); // Белый кролик стоит. Белый кролик прячется!
Теперь у класса Rabbit есть метод stop, который вызывает родительский super.stop() в процессе выполнения.

/////////////////////////////////////////////////////////////////////////

(!)Как упоминалось в главе Повторяем стрелочные функции, стрелочные функции не имеют super.

При обращении к super стрелочной функции он берётся из внешней функции:

class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
  }
}
В примере super в стрелочной функции тот же самый, что и в stop(), поэтому метод отрабатывает как и ожидается. Если бы мы указали здесь «обычную» функцию, была бы ошибка:

// Unexpected super
setTimeout(function() { super.stop() }, 1000);

/////////////////////////////////////////////////////////////////////////

(!)Если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор:

class Rabbit extends Animal {
  // генерируется для классов-потомков, у которых нет своего конструктора
  constructor(...args) {
    super(...args);
  }
}

(!)Конструкторы в наследуемых классах должны обязательно вызывать super(...), и (!) делать это перед использованием this..

class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// теперь работает
let rabbit = new Rabbit("Белый кролик", 10);
alert(rabbit.name); // Белый кролик
alert(rabbit.earLength); // 10

/////////////////////////////////////////////////////////////////////////

class Animal {
  name = 'animal';

  constructor() {
    alert(this.name); // (*)
  }
}

class Rabbit extends Animal {
  name = 'rabbit';
}

new Animal(); // animal
new Rabbit(); // animal
Здесь, класс Rabbit расширяет Animal и переопределяет поле name своим собственным значением.

В Rabbit нет собственного конструктора, поэтому вызывается конструктор Animal.

Что интересно, в обоих случаях: new Animal() и new Rabbit(), alert в строке (*) показывает animal.

Другими словами, родительский конструктор всегда использует своё собственное значение поля, а не переопределённое.

/////////////////////////////////////////////////////////////////////////

(!)причина заключается в порядке инициализации полей. Поле класса инициализируется:

1)Перед конструктором для базового класса (который ничего не расширяет),
2)Сразу после super() для производного класса.
В нашем случае Rabbit – это производный класс. В нем нет конструктора constructor(). Как было сказано ранее, это то же самое, как если бы был пустой конструктор, 
содержащий только super(...args).

Итак, new Rabbit() вызывает super(), таким образом, выполняя родительский конструктор, и (согласно правилу для производных классов) только после этого инициализируются поля 
его класса. На момент выполнения родительского конструктора ещё нет полей класса Rabbit, поэтому используются поля Animal.

/////////////////////////////////////////////////////////////////////////

1)Чтобы унаследовать от класса: class Child extends Parent: При этом Child.prototype.__proto__ будет равен Parent.prototype, так что методы будут унаследованы.
2)При переопределении конструктора: Обязателен вызов конструктора родителя super() в конструкторе Child до обращения к this.
3)При переопределении другого метода: Мы можем вызвать super.method() в методе Child для обращения к методу родителя Parent.
4)Внутренние детали: Методы запоминают свой объект во внутреннем свойстве [[HomeObject]]. Благодаря этому работает super, он в его прототипе ищет родительские методы.
Поэтому копировать метод, использующий super, между разными объектами небезопасно.
5)У функций-стрелок нет своего this и super, поэтому они «прозрачно» встраиваются во внешний контекст.
