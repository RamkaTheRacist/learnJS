Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
(!)В отличие от объектов, ключи не были приведены к строкам.

Методы и свойства:

*new Map() – создаёт коллекцию.
*map.set(key, value) – записывает по ключу key значение value.
*map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
*map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
*map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
*map.clear() – очищает коллекцию от всех элементов.
*map.size – возвращает текущее количество элементов.

(!)Хотя map[key] также работает, например, мы можем установить map[key] = 2, в этом случаеmap рассматривался бы как обычный JavaScript объект, 
таким образом это ведёт ко всем соответствующим ограничениям (только строки/символьные ключи и так далее).
Поэтому нам следует использовать методы map: set, get и так далее.

(!)Map может использовать объекты в качестве ключей.
Например:

let john = { name: "John" };

// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();

// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123

(!)Чтобы сравнивать ключи, объект Map использует алгоритм SameValueZero. Это почти такое же сравнение, что и ===, с той лишь разницей, что NaN считается равным NaN. 
Так что NaN также может использоваться в качестве ключа. Этот алгоритм не может быть заменён или модифицирован.

(!)Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:

map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Для перебора коллекции Map есть 3 метода:

1)map.keys() – возвращает итерируемый объект по ключам,
2)map.values() – возвращает итерируемый объект по значениям,
3)map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

Например:

let recipeMap = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
  alert(entry); // огурец,500 (и так далее)
}

(!)В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.
(!)Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

При создании Map мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, как здесь:

// массив пар [ключ, значение]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

(!)Если у нас уже есть обычный объект, и мы хотели бы создать Map из него, то поможет встроенный метод Object.entries(obj), 
который получает объект и возвращает массив пар ключ-значение для него, как раз в этом формате.

Так что мы можем создать Map из обычного объекта следующим образом:

let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
Здесь Object.entries возвращает массив пар ключ-значение: [ ["name","John"], ["age", 30] ]. Это именно то, что нужно для создания Map.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

(!)Метод Object.fromEntries делает противоположное: получив массив пар вида [ключ, значение], он создаёт из них объект

К примеру, у нас данные в Map, но их нужно передать в сторонний код, который ожидает обычный объект.

Вот как это сделать:

let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // создаём обычный объект (*)

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2

Вызов map.entries() возвращает итерируемый объект пар ключ/значение, как раз в нужном формате для Object.fromEntries.

Мы могли бы написать строку (*) ещё короче:

let obj = Object.fromEntries(map); // убрать .entries()
Это то же самое, так как Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно массив. А перебор map как раз возвращает пары ключ/значение, так же, 
как и map.entries(). Так что в итоге у нас будет обычный объект с теми же ключами/значениями, что и в map.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

*new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
*set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
*set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
*set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
*set.clear() – удаляет все имеющиеся значения.
*set.size – возвращает количество элементов в множестве.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:

let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});

(!)Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое значение valueAgain, и только потом целевой объект.
Это действительно так, значение появляется в списке аргументов дважды. Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента. 
Выглядит немного странно, но в некоторых случаях может помочь легко заменить Map на Set и наоборот.

(!)Set имеет те же встроенные методы, что и Map:
*set.keys() – возвращает перебираемый объект для значений,
*set.values() – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
*set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

